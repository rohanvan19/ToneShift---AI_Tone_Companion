{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar _getBoundingClientRect = _interopRequireDefault(require(\"../../modules/getBoundingClientRect\"));\nvar _setValueForStyles = _interopRequireDefault(require(\"../../modules/setValueForStyles\"));\nvar getRect = function getRect(node) {\n  var height = node.offsetHeight;\n  var width = node.offsetWidth;\n  var left = node.offsetLeft;\n  var top = node.offsetTop;\n  node = node.offsetParent;\n  while (node && node.nodeType === 1) {\n    left += node.offsetLeft + node.clientLeft - node.scrollLeft;\n    top += node.offsetTop + node.clientTop - node.scrollTop;\n    node = node.offsetParent;\n  }\n  top -= window.scrollY;\n  left -= window.scrollX;\n  return {\n    width: width,\n    height: height,\n    top: top,\n    left: left\n  };\n};\nvar _measureLayout = function measureLayout(node, relativeToNativeNode, callback) {\n  var relativeNode = relativeToNativeNode || node && node.parentNode;\n  if (node && relativeNode) {\n    setTimeout(function () {\n      if (node.isConnected && relativeNode.isConnected) {\n        var relativeRect = getRect(relativeNode);\n        var _getRect = getRect(node),\n          height = _getRect.height,\n          left = _getRect.left,\n          top = _getRect.top,\n          width = _getRect.width;\n        var x = left - relativeRect.left;\n        var y = top - relativeRect.top;\n        callback(x, y, width, height, left, top);\n      }\n    }, 0);\n  }\n};\nvar elementsToIgnore = {\n  A: true,\n  BODY: true,\n  INPUT: true,\n  SELECT: true,\n  TEXTAREA: true\n};\nvar UIManager = {\n  blur: function blur(node) {\n    try {\n      node.blur();\n    } catch (err) {}\n  },\n  focus: function focus(node) {\n    try {\n      var name = node.nodeName;\n      if (node.getAttribute('tabIndex') == null && node.isContentEditable !== true && elementsToIgnore[name] == null) {\n        node.setAttribute('tabIndex', '-1');\n      }\n      node.focus();\n    } catch (err) {}\n  },\n  measure: function measure(node, callback) {\n    _measureLayout(node, null, callback);\n  },\n  measureInWindow: function measureInWindow(node, callback) {\n    if (node) {\n      setTimeout(function () {\n        var _getBoundingClientRec = (0, _getBoundingClientRect[\"default\"])(node),\n          height = _getBoundingClientRec.height,\n          left = _getBoundingClientRec.left,\n          top = _getBoundingClientRec.top,\n          width = _getBoundingClientRec.width;\n        callback(left, top, width, height);\n      }, 0);\n    }\n  },\n  measureLayout: function measureLayout(node, relativeToNativeNode, onFail, onSuccess) {\n    _measureLayout(node, relativeToNativeNode, onSuccess);\n  },\n  updateView: function updateView(node, props) {\n    for (var prop in props) {\n      if (!Object.prototype.hasOwnProperty.call(props, prop)) {\n        continue;\n      }\n      var value = props[prop];\n      switch (prop) {\n        case 'style':\n          {\n            (0, _setValueForStyles[\"default\"])(node, value);\n            break;\n          }\n        case 'class':\n        case 'className':\n          {\n            node.setAttribute('class', value);\n            break;\n          }\n        case 'text':\n        case 'value':\n          node.value = value;\n          break;\n        default:\n          node.setAttribute(prop, value);\n      }\n    }\n  },\n  configureNextLayoutAnimation: function configureNextLayoutAnimation(config, onAnimationDidEnd) {\n    onAnimationDidEnd();\n  },\n  setLayoutAnimationEnabledExperimental: function setLayoutAnimationEnabledExperimental() {}\n};\nvar _default = exports[\"default\"] = UIManager;","map":{"version":3,"names":["_getBoundingClientRect","_interopRequireDefault","require","_setValueForStyles","getRect","node","height","offsetHeight","width","offsetWidth","left","offsetLeft","top","offsetTop","offsetParent","nodeType","clientLeft","scrollLeft","clientTop","scrollTop","window","scrollY","scrollX","_measureLayout","measureLayout","relativeToNativeNode","callback","relativeNode","parentNode","setTimeout","isConnected","relativeRect","_getRect","x","y","elementsToIgnore","A","BODY","INPUT","SELECT","TEXTAREA","UIManager","blur","err","focus","name","nodeName","getAttribute","isContentEditable","setAttribute","measure","measureInWindow","_getBoundingClientRec","onFail","onSuccess","updateView","props","prop","Object","prototype","hasOwnProperty","call","value","configureNextLayoutAnimation","config","onAnimationDidEnd","setLayoutAnimationEnabledExperimental","_default","exports"],"sources":["C:/Users/vanma/StudioProjects/ToneShift/toneshift-frontend/node_modules/react-native-web/dist/exports/UIManager/index.js"],"sourcesContent":["/**\n * Copyright (c) Nicolas Gallagher.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport getBoundingClientRect from '../../modules/getBoundingClientRect';\nimport setValueForStyles from '../../modules/setValueForStyles';\nvar getRect = node => {\n  var height = node.offsetHeight;\n  var width = node.offsetWidth;\n  var left = node.offsetLeft;\n  var top = node.offsetTop;\n  node = node.offsetParent;\n  while (node && node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n    left += node.offsetLeft + node.clientLeft - node.scrollLeft;\n    top += node.offsetTop + node.clientTop - node.scrollTop;\n    node = node.offsetParent;\n  }\n  top -= window.scrollY;\n  left -= window.scrollX;\n  return {\n    width,\n    height,\n    top,\n    left\n  };\n};\nvar measureLayout = (node, relativeToNativeNode, callback) => {\n  var relativeNode = relativeToNativeNode || node && node.parentNode;\n  if (node && relativeNode) {\n    setTimeout(() => {\n      if (node.isConnected && relativeNode.isConnected) {\n        var relativeRect = getRect(relativeNode);\n        var _getRect = getRect(node),\n          height = _getRect.height,\n          left = _getRect.left,\n          top = _getRect.top,\n          width = _getRect.width;\n        var x = left - relativeRect.left;\n        var y = top - relativeRect.top;\n        callback(x, y, width, height, left, top);\n      }\n    }, 0);\n  }\n};\nvar elementsToIgnore = {\n  A: true,\n  BODY: true,\n  INPUT: true,\n  SELECT: true,\n  TEXTAREA: true\n};\nvar UIManager = {\n  blur(node) {\n    try {\n      node.blur();\n    } catch (err) {}\n  },\n  focus(node) {\n    try {\n      var name = node.nodeName;\n      // A tabIndex of -1 allows element to be programmatically focused but\n      // prevents keyboard focus. We don't want to set the tabindex value on\n      // elements that should not prevent keyboard focus.\n      if (node.getAttribute('tabIndex') == null && node.isContentEditable !== true && elementsToIgnore[name] == null) {\n        node.setAttribute('tabIndex', '-1');\n      }\n      node.focus();\n    } catch (err) {}\n  },\n  measure(node, callback) {\n    measureLayout(node, null, callback);\n  },\n  measureInWindow(node, callback) {\n    if (node) {\n      setTimeout(() => {\n        var _getBoundingClientRec = getBoundingClientRect(node),\n          height = _getBoundingClientRec.height,\n          left = _getBoundingClientRec.left,\n          top = _getBoundingClientRec.top,\n          width = _getBoundingClientRec.width;\n        callback(left, top, width, height);\n      }, 0);\n    }\n  },\n  measureLayout(node, relativeToNativeNode, onFail, onSuccess) {\n    measureLayout(node, relativeToNativeNode, onSuccess);\n  },\n  updateView(node, props) {\n    for (var prop in props) {\n      if (!Object.prototype.hasOwnProperty.call(props, prop)) {\n        continue;\n      }\n      var value = props[prop];\n      switch (prop) {\n        case 'style':\n          {\n            setValueForStyles(node, value);\n            break;\n          }\n        case 'class':\n        case 'className':\n          {\n            node.setAttribute('class', value);\n            break;\n          }\n        case 'text':\n        case 'value':\n          // native platforms use `text` prop to replace text input value\n          node.value = value;\n          break;\n        default:\n          node.setAttribute(prop, value);\n      }\n    }\n  },\n  configureNextLayoutAnimation(config, onAnimationDidEnd) {\n    onAnimationDidEnd();\n  },\n  // mocks\n  setLayoutAnimationEnabledExperimental() {}\n};\nexport default UIManager;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}